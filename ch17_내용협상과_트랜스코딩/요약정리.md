# 요약정리
- 교재중심의 요약정리를 목표로 합니다. (+ 개인적 견해)

---
## 목차
 ### 17.1 내용 협상 기법
 ### 17.2 클라이언트 주도 협상
 ### 17.3 서버 주도 협상
 ### 17.4 투명 협상
 ### 17.5 트랜스코딩
 ### 17.6 다음단계

---
### 17. 내용협상과 트랜스코딩
- 내 웹페이지는 한글/ 영어를 제공한다. 이때 사용자가 내 URL로 접근 요청했을때 어떤 언어로 제공해야되는가?
- 뿐만 아니라 pc환경이 아닌 다른 환경에서 접근할때 적절한 형태 변환이 필요(모든 환경에 HTML을 주는건 부적절)
- 내용협상: 하나의 URL이 여러 가지 리소스 중 적합한것에 대응되도록 하는것
- 배리언트(Varient): 서로 다른 리소스(버전)
- 트랜스코딩: HTTP 클라이언트와 서버 사이의 내용 협상에 대한 응답에서 수행(적절한 형태로 바꿔서 응답)

### 17.1 내용 협상 기법
- 대표적인 방법 3가지가 존재
    #### 1. 클라이언트 주도
    - 동작
        - 클라이언트가 요청 -> 서버는 선택지를 응답 -> 클라이언트가 선택
    - 장점
        - 클라이언트 입장에서 최선
    - 단점
        - 대기시간 증가
    #### 2. 서버 주도
    - 동작
        - 서버가 클라이언트의 요청 헤더를 검증해서 제공
    - 장점
        - 클라이언트 주도보다 빠르다(Vary 헤더를 사용)
    - 단점
        - 적절한게 없다면, 서버는 추측해야된다. (잘못된걸 줄 수있다.)
    #### 3. 투명
    - 동작
        - 투명한 중간 장치(예. 프락시 캐시)가 서버대신 판단
    - 장점
        - 클라이언트 주도보다 빠르다
    - 단점
        - 정형화된 명세가 없다.

### 17.2 클라이언트 주도 협상
- 서버에서 선택지를 응답받을때 선택지(링크)가 담긴 HTML 혹은 상태코드로 받는다.
- 대기시간이 증가되는 문제점외에 URL 선택에 어려움이 발생
```html
    1. www.naver.com 요청
    2. www.naver.com/korean 과 www.naver.com/english를 받는다.
    3. 나는 www.naver.com/korean을 사용할텐데 북마크는 어디다 해야될까?
    4. 그리고 영어사용자에겐 어느 URL을 추천해줘야 될까?
```
### 17.3 서버 주도 협상
- 클라이언트 주도 협상은 커뮤니케이션 증가로 대기시간이 길어진다. 해당 문제를 해결하려면 서버가 알아서, 잘, 딱, 깔끔하게, 센스있게 처리하는 것.
- 어떻게? **클라이언트의 요청 헤더**에서 힌트를 얻어서 제공
- 클라이언트의 요청헤더중 내용 협상 헤더, 다른 헤더(User-Agent, Vary...)를 분석한다.

### 17.3.1 내용 협상 헤더
| 헤더       | 설명                    |
|:--------:|:---------------------:|
| Accept | 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다.          |
| Accept-Language | 서버가 어떤 언어로 보내도 되는지 알려준다.         |
| Accept-Charset | 서버가 어떤 차셋으로 보내도 되는지 알려준다.         |
| Accept-Encoding | 서버가 어떤 인코딩으로 보내도 되는지 알려준다.         |

- 놀랍게도 엔터티 헤더들과 비슷해보인다.
- 여전히 문제점은 스페인어가 없을때 스페인어 사용자한테 남은 언어중에 어떤걸 제공해야될까?
- 해결: 그 사람의 선호도에 대한 정보값을 추가로 받는다 == 품질값(q)

### 17.3.2 내용 협상 헤더의 품질값
- 형태
```html
    Accept: [ text/html, application/json, image/* ... ]
    Accept-Language: fr-CH, fr;q=0.9, en;q=0.8 de;q=0.7, *;q=0.5
    Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1
    Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1
```
- 0.0 <= q <= 1.0
- 각 언어에 따라 선호도를 가지고 있고 만약, 하나도 없을 경우엔 뒤에서 설명한다.

### 17.3.3 그 외의 헤더들에 의해 결정
- 요청 헤더들을 이용해서 요청을 만든다: 자바스크립트를 제공하지 않는 오래된 웹브라우저는 자바스크립트를 제외한 페이지를 돌려준다. 등등
- Vary 헤더: 캐시는 반드시 캐시된 문서의 올바른 '최선의'버전을 제공해주려 하기 때문에 서버의 결정을 돕기 위해서 어떤 요청 헤더를 참고있는지 알려준다.

### 17.3.4 아파치의 내용 협상
- 아파치 웹 서버가 내용 협상하는 방법은 아래와 같다
- 기본 원리: 서버가 제공할 각각의 버전들(배리언트)을 아파치 서버의 적절한 디렉터리에 보관하고 type-map 파일 사용하기, Multiviews 사용하기를 사용하여 동작한다.
- type-map 파일 사용하기: 각 배리언트에 맞게 URI를 지정해서 기록한다.
```html
    URI: index.html

    URI: index.en.html
    content-type: text/html
    content-language: en

    URI: index.fr.de.html
    content-type: text/html;charset=iso-8859-2
    content-language: fr, de
```

- Multiviews(지시어) 사용하기: 아파치가 디렉터리에 대해 자동으로 type-map을 생성하도록 한다.

### 17.3.5 서버 측 확장
- 마이크로소트의 액티브 서버 페이지와 같이 서버 쪽에서 확장하는 방법

### 17.4 투명 협상
- 투명한 중개 장치(프락시)가 클라이언트와 서버 주도의 협상을 하면서 서버 부하 감소
- 서버 주도의 협상을 하려면 중개 장치가 **요청의 어떤 헤더**가 필요한지 알고 있어야 한다.
- 이를 서버가 Vary헤더에 포함하여 중개 장치에 보낸다.
- 대표적인 중개 장치: 캐시 (프락시)
- 단일한 URL을 통해 접근할 수 있는 문서의 여러 다른 사본을 저장할 수 있고 내장된 범용 트랜스코더는 특정 서버에 국한되지 않고 어떤 콘텐츠든 트랜스코딩할 수 있다.

### 17.4.1 캐시와 얼터네이트
- 캐시: 우리가 콘텐츠를 캐시하는건 다음에 재사용될것을 기대하고 요청을 받으면 꺼내서 준다. 만약 Accept헤더에 변경이 된다면, 기존에 저장된 캐시와 새로운 요청은 다른 리소스이지만 같은 URI라서 캐시를 꺼내는 사고가 발생한다.
- 위의 사고에서 다른 버전을 배리언트 혹은 얼터네이트라 부릅니다.

### 17.4.2 Vary 헤더
- 위의 사고를 어떻게 해결하는가? 간단하게 Accept헤더까지 확인하면된다.
- 그리고 확인해야 되는 부분을 서버가 Vary헤더에 기록하여 캐시에 넘기면 캐시는 캐시된 배리언트와 새로운 요청 헤더, 기준인 Vary헤더를 비교하여 변경사항이 없다면 캐시된 리소스를 준다.

### 17.5 트랜스코딩
- 내용 협상의 기본 조건은 클라이언트의 요구에 맞는 문서가 존재해야 동작한다.(맞든 틀리든)
- 그러나 놀랍게도 맞는 문서가 없어도 기존의 다른 문서를 클라이언트의 요청에 맞는 무언가로 바꿀 수 있다. 이를 **트랜스코딩**이라 한다.
- 종류: 포맷변환, 정보 합성, 내용 주입
- 예시

| 전      | 후                    |
|:--------:|:---------------------:|
| HTML문서 | WML문서          |
| 고해상도 이미지 | 저해상도 이미지         |
| 광고 페이지 | 광고(x) 페이지         |

### 17.5.1 포맷 변환
- 의미: 파일 포맷을 변환한다.
- 고해상도 이미지를 저해상도 이미지로 바꾸거나 HTML문서를 읽을 수 없는 환경일때(ex.WAP) WML문서로 바꾸는 등 보통 콘텐츠의 효율성, 보안성을 위해 변환.

### 17.5.2 정보 합성
- 의미: 문서에서 정보의 요점을 추출하는 것

### 17.5.3 콘텐츠 주입
- 의미: 콘텐츠에 새로운 콘텐츠를 주입하는 것
- 포맷변환과 정보합성이 콘텐츠의 양을 줄이는 거라면 콘텐츠 주입은 양을 늘린다.
- 왜? 대표적인 예시로 사용자 추적 시스템을 통해서 얻은 사용자 정보를 기반으로 적절한 광고를 삽입한다.

### 17.5.4 트랜스코딩 vs 정적으로 미리 생성해놓기
- 트랜스코딩의 대안은 웹 서버에 그냥 전부 미리 만들어 놓는것.
- 그러나 현실적인 문제때문에 불가능하고 원본 리소스자체를 요청마다 수정해서 제공하는 방법도 있다.
- 그러나 대기시간이 증가하고 이는 비용증가를 초래한다. 그래서 나온 해결책이 변환(수정)과정만 더 싼 프락시에서 처리시키는 것.