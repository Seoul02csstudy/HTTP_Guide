# 20장 리다이렉션과 부하 균형

## 1. 왜 리다이렉트인가?
- HTTP 애플리케이션이 원하는 것
	- 신뢰할 수 있는 HTTP 트랜잭션의 수행
	- 지연 최소화
	- 네트워크 대역폭 절약

- 리다이렉션
	- 최적의 분산된 콘텐츠를 찾는 것을 도와주는 기법의 집합

## 2. 리다이렉트 할 곳
- 서버, 프락시, 캐시, 게이트웨이가 모두 공통적으로 서버의 특성을 갖고 있기 때문에, 많은 리다이렉션 기법이 그들 모두에서 동작한다. 그러나 어떤 리다이렉션 기술들은 특정 종류의 종단만을 위해 특별히 설계되어 일반적인 적용이 불가능하다.
- 서버로의 리다이렉트는 휘발유를 찾는 운전기사를 가장 가까운 주유소로 보내는 것이다.
- 프락시로의 리다이렉트는 진입로의 트래픽을 근처에 있는 지름길로 빨아들이는 것과 같다.

## 3. 리다이렉션 프로토콜의 개요
- HTTP 메시지를 웹 서버로 가급적 빨리 보내는 것이 리다이렉션의 목표다.
- HTTP 메시지는 HTTP 애플리케이션과 라우팅 장치에 영향을 받는다.
- 메시지를 서버로 리다이렉트하기 위한 여러 방법들이 존재한다.

## 4. 일반적인 리다이렉션 방법
### 4.1 HTTP 리다이렉션
- 요청을 처리하는 서버는 가용한 것들 중 부하가 가장 적은 콘텐츠 서버를 찾아서 브라우저의 요청을 그 서버로 리다이렉트 한다.
- 리다이렉트를 하는 서버가 클라이언트의 아이피 주소를 아는 것은 좀 더 근거에 선택하므로 장점이다.

**단점**
- 어떤 서버로 리다이렉트 할 지 결정하려면 원 서버는 상당히 많은 처리를 해야 한다.
- 페이지에 접근할 때마다 두 번의 왕복이 필요하므로 사용자가 더 오래 기다리게 된다.
- 리다이렉트 서버가 고장나면, 사이트도 고장난다.

### 4.2 DNS 리다이렉션
- 클라이언트가 웹 사이트에 접근하려고 시도할 때마다, 도메인 이름은 반드시 아이피 주소로 분석되어야 한다.
- DNS는 하나의 도메인에 여러 아이피 주소가 결부되는 것을 허용한다.
- DNS 분석자는 클라이언트의 운영체제일 수도 있고, 클라이언트의 네트워크에 있는 DNS 서버이거나 더 원격에 있는 DNS 서버일 수도 있다.

**라운드로빈**
- 가장 단순한 리다이렉션 기법이다.
- DNS 라운드 로빈은 웹 서버 팜 전체에 대한 부하의 균형을 유지하기 위해 DNS 호스트 명 분석 기능을 사용한다.
- DNS 클라이언트는 다중 주소 집합의 첫 번째 주소를 사용한다.
- DNS 서버는 룩업이 끝났을 때마다 주소를 순환시킨다.

**DNS캐싱의 효과**
- DNS 룩업은 애플리케이션, 운영체제 등 DNS 서버에 의해 재사용 되어 비용을 줄이게 된다.
- 클라이언트의 수가 어느정도 이상만 된다면, 부하는 모든 서버에 잘 분산되었다고 할 수 있다.

**그 외 다른 DNS 기반 리다이렉션 알고리즘**
- 부하 균형 알고리즘
- 근접 라우팅 알고리즘
- 결함 마스킹 알고리즘

### 4.3 임의 캐스팅 어드레싱
- 여러 흩어진 웹 서버들은 정확히 같은 아이피 주소를 갖고 클라이언트의 요청을 클라이언트에게서 가장 가까운 서버로 보내주기 위해 백본 라우터의 '최단거리' 라우팅 능력에 의지한다.
- 백본 라우터가 임의 캐스트 주소를 목적지로 하는 패킷을 받았을 때, 그 아이피 주소를 받아들일 수 있는 가장 가까운 라우터를 찾는다.
- 서버는 반드시 라우터의 언어로 말해야하고 라우터는 일어날 수 있는 주소충돌을 반드시 다룰 수 있어야 한다.

### 4.4 아이피 주소 포워딩
- 스위치나 레이어4를 이해하는 장비는 들어오는 패킷에 대해 TCP/IP 어드레싱을 검증하고 패킷을 목적지 맥 주소가 아니라 목적지 아이피 주소의 변경에 따라 라우팅한다.
- 목적지 서버가 한 홉 거리에 있을 필요가 없다.
- 스위치는 반드시 그 커넥션을 통해 클라이언트에게 응답을 돌려줘야 한다.

## 5. 프락시 리다이렉션 방법
### 5.1 명시적 브라우저 설정
- 대부분의 브라우저에는 프락시 서버에 접촉하기 위한 프락시 이름, 아이피 주소, 포트번호를 설정하는 메뉴가 존재한다.
- 사용자의 설정에 따라 모든 요청에 대해 프락시와 접촉한다.

**단점**
- 만약 프락시가 다운되었거나 브라우저가 잘못 설정되었다면, 사용자는 접속 문제에 마주하게 된다.
- 네트워크 아키텍처를 변경했을 때 그 변경사항을 모든 최종사용자에게 전파하는 것이 어렵다.

### 5.2 프락시 자동설정(Proxy Auto-configuration,PAC)
- 브라우저가 동적으로 자신을 설정할 수 있게 하는 것이다.
- PAC는 브라우저들이 URL별로 접촉해야 할 프락시를 지정한 PAC 파일이라 불리는 특별한 파일을 찾도록 하는 것이다.
- 브라우저는 반드시 PAC 파일을 얻기 위해 지정된 서버에 접촉하도록 설정되어 있다.
- 브라우저는 재시작 할때마다 PAC파일을 가져온다.
- PAC 파일은 함수를 반드시 정의해야하는 자바스크립트 파일이다. 
```
function FindProxyForURL(url,host)
```
### 5.3 웹 프락시 자동발견 프로토콜
- 웹 프락시 자동발견 프로토콜은 최종 사용자가 수동으로 프락시 설정을 할 필요도, 투명한 트래픽 인터셉트에 의존할 필요도 없이 웹 브라우저가 근처의 프락시를 찾아내어 사용할 수 있게 해 주는 방법을 제공하는 것을 목적으로 하고 있다.

**추가적 알고리즘에 관한 설명은 ~546p 까지를 참조**
## 6. 캐시 리다이렉션 방법
- 신뢰성 높고, 고성능에, 콘텐츠 지각 디스패칭까지 가능한 프로토콜을 얘기할 것임

### 6.1 WCCP 리다이렉션
- WCCP는 라우터들과 캐시들 사이의 대화를 관리하여 라우터가 캐시를 검사하고, 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게 해준다.
- **WCCP리다이렉션 동작**
	- 네트워크가 필요. 이 네트워크에는 WCCP를 사용할 수 있는 라우터와, 다른 캐시와 의사소통 할 수 있는 캐시가 포함되어야 한다.
	- 라우터들의 집합과 그들의 대상이 되는 캐시들이 WCCP 서비스 그룹을 구성한다. 
	- HTTP 요청이 서비스그룹에 도착했을 때, 라우터는 그 요청을 처리하기 위해 서비스그룹의 캐시 중 하나를 선택한다.
	- 라우터는 요청 패킷을, 캐시의 아이피 주소와 함께 캡슐화하거나, 아이피 맥 포워딩을 하여 캐시로 보낸다.
	- 서비스 그룹의 구성원들은 지속적으로 다른 구성원들의 가용성을 확인하기 위해 하트비트 메시지를 교환한다.

## 7. 인터넷 캐시 프로토콜
- 인터넷 캐시 프로토콜(ICP)는 캐시들이 형제 캐시에서 일어난 캐시 적중을 찾아볼 수 있게 해준다.
- ICP는 객체 발견 프로토콜이다. 캐시는 이 프로토콜을 사용해 근처의 캐시 모두에게 특정 URL을 갖고 있는지 한번에 물어본다. 근처의 캐시들은 그 URL을 갖고 있다면 'HIT' 아니면 'MISS'라고 짧은 메시지로 답한다.
- ICP 메시지는 파싱 하기 쉽도록 네트워크 바이트 순서에 따라 32비트 크기로 맞추어진 구조체다. 이 메시지들은 UDP 다이어그램을 통해 전송된다.

## 8. 캐시 배열 라우팅 프로토콜
- 프락시 서버는 사용자 개개인으로부터의 요청을 가로채어 요청한 웹 객체의 캐시된 사본을 제공함으로써 인터넷으로 향하는 트래픽을 대폭 줄여준다. 그러나 사용자의 증가에 따라 대량의 트래픽은 프락시 서버 자체에 과도한 부하를 줄 수 있다.
- 이 문제에 대한 해결책 중 하나는 부하를 분산하기 위해 사용하는 프락시 서버를 여러대로 늘리는 것이다.
- CARP 는 프락시 서버의 배열이 클라이언트의 시점에서는 마치 하나의 논리적인 캐시처럼 보이도록 관리해주는 표준이다. (ICP 의 대안)
- 각 구성요소 서버가 전체 캐시된 문서의 일부만 갖고있는 하나의 큰 서버처럼 동작한다.
- ICP 프로토콜로 서로 연결된 프락시 서버들 각각은 콘텐츠의 쓸데없는 복제본도 갖고 있는, 프락시 서버들 전체에 걸친 웹 객체에 대한 중복된 엔트리가 허용되는 독립적인 캐시이다.

## 9. 하이퍼텍스트 캐싱 프로토콜
- 하이퍼텍스트 캐싱 프로토콜은 형제들이 URL과 모든 요청 및 응답 헤더를 사용하여 서로에게 문서의 존재 여부에 대한 질의를 할 수 있도록 해줌으로써 적중이 아님에도 적중으로 잘못 처리될 확률을 줄인다.
- HTCP는 형제 캐시들이 캐시 안에 있는 선택된 문서의 추가 및 삭제를 모니터링하고 요청할 수 있게, 그리고 서로의 캐시된 문서에 대한 캐싱 정책을 변경할 수 있게 해준다.
- 만약 근처 캐시가 그 문서를 가지고 있다면, 요청 캐시는 그 캐시에 HTTP 커넥션을 열고 그 문서를 가져온다.




