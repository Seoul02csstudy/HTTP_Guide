# 커넥션 관리

* TCP 커넥션
  
  * 신뢰할 수 있는 데이터 전송 통로인 TCP
    
    * HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과
    
    * TCP는 충돌 없이 순서에 맞게 HTTP 데이터를 전달
  
  * TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다
    
    * 세그먼트 단위로 데이터 스트림을 나누고, IP 패킷에 담겨 다른 IP주소로 전달
    
    * IP패킷 content: IP 패킷 헤더, TCP 세그먼트 헤더, TCP 데이터 조각
      
      <img src="커넥션%20관리_assets/6fcb55fb931c1e2864b467a635c01fbb2123cc58.png" title="" alt="4_1_2_2.png" width="482">
  
  * TCP 커넥션 유지하기
    
    * 발신지 IP주소, 수신지 IP주소, 발신지 포트, 수신지 포트 4가지로 식별
  
  * TCP 소켓 프로그래밍
    
    * 소켓 API를 사용하면, TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.
      
      ![4_1_4.png](커넥션%20관리_assets/0e2f71e9db1825dfb6da775c9f1f134fa1e44307.png)

* TCP의 성능에 대한 고려
  
  * HTTP 트랜잭션 지연
    
    <img src="커넥션%20관리_assets/573b29ef55b261babe3f23eb8b415c943e3b712e.png" title="" alt="4_2_1.png" data-align="inline">
    
    * 대부분 TCP 네트워크 지연 때문에 발생
      
      * 클라이언트가 URI에서 웹 서버 IP 주소와 포트 번호를 알아내야함
      
      * TCP 커넥션 요청을 서버로 보내고, 허가 응답 회신 대기
      
      * 커넥션 이후, 서버에서 데이터 읽고 처리 후 응답
  
  * TCP 커넥션 핸드셰이크 지연
    
    ![4_2_2.png](커넥션%20관리_assets/ae024fb6ce5fd86ab4428a11ba1457d6b55be286.png)
  
  * 확인응답 지연
    
    * TCP 세그먼트는 순번과 무결성 체크섬을 가짐
    
    * 확인응답 패킷을 편승시키는 '확인응답 지연' 알고리즘 구현
  
  * TCP 느린 시작
    
    * 패킷이 성공적으로 전달될수록 더 많은 패킷을 허용
  
  * 네이글 알고리즘과 TCP_NODELAY
    
    * 네이글 알고리즘 : 작은 데이터로 많은 패킷을 전송하는 것을 방지
    
    * 문제점
      
      * 패킷에 데이터를 채우기 위해 지연
      
      * 확인응답 지연 알고리즘과 함께 쓰일 때, 더 많은 시간 초래
    
    * TCP_NODELAY로 네이글 알고리즘 비활성화 가능
  
  * TIME_WAIT의 누적과 포트 고갈
    
    * 포트 고갈은 성능 측정 시에 심각한 성능 저하, 실제 상황은 문제 X
    
    * TCP 커넥션을 끊으면, 제어영역에 IP 주소와 포트번호를 일정 시간 동안 저장하여 같은 주소와 포트 번호 사용하는 새로운 TCP 커넥션 생성 방지

* HTTP 커넥션 관리
  
  * 순차적인 트랜잭션 처리에 의한 지연
    
    ![4_3_2.png](커넥션%20관리_assets/96aa73221f96a89919a54c3ee0f133df51a7e88f.png)

* 병렬 커넥션
  
  * 병렬 커넥션은 페이지를 더 빠르게 내려받는다
    
    * 병렬로 연결해 커넥션 지연을 합쳐서, 지연시간을 대폭 줄임
      
      ![4_4_1.png](커넥션%20관리_assets/1e37125a07dc9ac51c03c6db5619edbc2cc7eab5.png)
  
  * 병렬 커넥션이 항상 더 빠르지는 않다
    
    * 대역폭이 좁을 때, 장점 사라짐
    
    * 여러개 커넥션을 할 때, 메모리 소모 커짐
  
  * 병렬 커넥션은 더 빠르게 '느껴질 수' 있다
    
    * 화면이 동시에 나오기 때문에

* 지속 커넥션
  
  * 지속 커넥션 vs 병렬 커넥션
    
    * 둘 다 장단점이 있기에 합쳐서 쓴다
    
    * 병렬 커넥션의 지속 커넥션과 비교했을 때 단점 ( 장점은 위에서 보였음)
      
      * 각 트랙잭션마다 시간과 대역폭 소요
      
      * TCP 느린시작
      
      * 실제 연결할 수 있는 커넥션 수 제한
    
    * 결론
      
      * 몇개의 병렬 커넥션만 유지하고, 지속 커넥션을 사용한다
    
    * HTTP/1.0+ 에는 keep-alive 커넥션
    
    * HTTP/1.1 에는 지속 커넥션
  
  * Keep-Alive 동작
    
    * HTTP/1.1 에선 빠졌지만, 많이 사용하기 때문에 동작 알고 있어야함
    
    * 요청에 Connection:Keep-Alive를 헤더에 포함, 응답 또한 와야함
    
    * 응답에서 안오면, 커넥션 끊을거라 추정
  
  * Keep-Alive 옵션
    
    * 위의 동작은, 유지하는거라 했는데 사실은 유지하기를 바라는거... 이것들은 옵션을 통해 제어할 수 있다
    
    * timeout 파라미터는 커넥션 유지 기간을 의미
    
    * max 파라미터는 트랜젝션 몇개 처리할 때 까지 유지할지 알려줌(응답에서 보냄, 또한 보장이 안됨...)
      
      ![4_5_4.png](커넥션%20관리_assets/cb5857a368a5e5d9d6e318e7cb5df60e5e221224.png)
  
  * HTTP/1.1의 지속 커넥션
    
    * 목적은 keep-alive 커넥션과 같지만, 더 잘 동작
    
    * keep-alive와 달리 기본으로 활성화되어있음
    
    * 그래서, 끊으려면 Connection: close 를 명시해야함
    
    * 명시안해도 영원히 지속되는건 아님..

* 파이프라인 커넥션
  
  <img src="커넥션%20관리_assets/fa3b72072368a5b76b354dad2b5a7b393d766702.png" title="" alt="4_6.png" width="537">
